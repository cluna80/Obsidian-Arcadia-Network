"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileLink = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const lodash_1 = __importDefault(require("lodash"));
const semver_1 = __importDefault(require("semver"));
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const compile_1 = require("./compile");
async function compileLink(taskArgs, hre) {
    if (!hre.network.zksync) {
        throw new errors_1.ZkSyncSolcPluginError('This task is only available for zkSync network');
    }
    await hre.run(constants_1.TASK_DOWNLOAD_ZKSOLC);
    await hre.run(constants_1.TASK_UPDATE_SOLIDITY_COMPILERS);
    if (semver_1.default.lt(hre.config.zksolc.version, constants_1.ZKSOLC_COMPILER_VERSION_WITH_LIBRARY_LINKING)) {
        return undefined;
    }
    const contractFQN = (0, utils_1.generateFQN)(taskArgs.sourceName, taskArgs.contractName);
    const contractFilePath = path_1.default.join(hre.config.paths.artifacts, taskArgs.sourceName, `${taskArgs.contractName}.zbin`);
    const artifact = await hre.artifacts.readArtifact(contractFQN);
    fs_1.default.writeFileSync(contractFilePath, artifact.bytecode);
    const output = await (0, compile_1.link)(hre.config.zksolc, await (0, utils_1.getLibraryLink)(hre, taskArgs.libraries, contractFilePath));
    if (!lodash_1.default.isEmpty(output.unlinked)) {
        if (taskArgs.withoutError) {
            return undefined;
        }
        throw new errors_1.ZkSyncSolcPluginError(`Libraries for contract ${contractFQN} are not linked: ${Object.values(output.unlinked[contractFilePath])
            .map((lib) => `${lib}`)
            .join(', ')}`);
    }
    if (!lodash_1.default.isEmpty(output.ignored)) {
        console.warn(`Linking of some libraries for contract ${contractFQN} are ignored as they are provided as the duplicate of the already linked libraries.`);
    }
    const newBytecode = fs_1.default.readFileSync(contractFilePath, { encoding: 'utf-8' });
    return newBytecode;
}
exports.compileLink = compileLink;
//# sourceMappingURL=plugin.js.map