"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZksolcCompilerDownloader = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
const errors_1 = require("./../errors");
/**
 * This class is responsible for downloading the zksolc binary.
 */
class ZksolcCompilerDownloader {
    static async getDownloaderWithVersionValidated(version, configCompilerPath, compilersDir) {
        if (!ZksolcCompilerDownloader._instance) {
            if (version !== constants_1.ZKSOLC_COMPILER_PATH_VERSION && configCompilerPath) {
                throw new errors_1.ZkSyncSolcPluginError(`When a compiler path is provided, specifying a version of the zksolc compiler in Hardhat is not allowed. Please omit the version and try again.`);
            }
            if (version === constants_1.ZKSOLC_COMPILER_PATH_VERSION && !configCompilerPath) {
                throw new errors_1.ZkSyncSolcPluginError(`The zksolc compiler path is not specified for local or remote origin.`);
            }
            if (version === 'latest') {
                throw new errors_1.ZkSyncSolcPluginError(constants_1.COMPILER_ZKSOLC_LATEST_DEPRECATION);
            }
            if (version !== 'latest' && version !== constants_1.ZKSOLC_COMPILER_PATH_VERSION && (0, utils_1.isVersionForDeprecation)(version)) {
                throw new errors_1.ZkSyncSolcPluginError((0, constants_1.COMPILER_ZKSOLC_DEPRECATION_FOR_SOLC_VERSION)(version));
            }
            ZksolcCompilerDownloader._instance = new ZksolcCompilerDownloader(version, configCompilerPath, compilersDir);
        }
        return ZksolcCompilerDownloader._instance;
    }
    /**
     * Use `getDownloaderWithVersionValidated` to create an instance of this class.
     */
    constructor(_version, _configCompilerPath, _compilersDirectory) {
        this._version = _version;
        this._configCompilerPath = _configCompilerPath;
        this._compilersDirectory = _compilersDirectory;
        this._isCompilerPathURL = (0, utils_1.isURL)(_configCompilerPath);
    }
    getVersion() {
        return this._version;
    }
    getCompilerPath() {
        let salt = '';
        if (this._isCompilerPathURL) {
            // hashed url used as a salt to avoid name collisions
            salt = (0, utils_1.saltFromUrl)(this._configCompilerPath);
        }
        else if (this._configCompilerPath) {
            return this._configCompilerPath;
        }
        // Add mock extension '0' so windowns can run the binary
        return path_1.default.join(this._compilersDirectory, 'zksolc', `zksolc-${this._configCompilerPath ? `remote` : `v${this._version}`}${salt ? '-' : ''}${salt}${this._configCompilerPath ? '.0' : ''}`);
    }
    async isCompilerDownloaded() {
        if (this._configCompilerPath && !this._isCompilerPathURL) {
            await this._verifyCompilerAndSetVersionIfNeeded();
            return true;
        }
        if (this._configCompilerPath && this._isCompilerPathURL) {
            const compilerPathFromUrl = this.getCompilerPath();
            if (await fs_extra_1.default.pathExists(compilerPathFromUrl)) {
                await this._verifyCompilerAndSetVersionIfNeeded();
                return true;
            }
            return false;
        }
        const compilerPath = this.getCompilerPath();
        return fs_extra_1.default.pathExists(compilerPath);
    }
    async downloadCompiler() {
        try {
            console.info(chalk_1.default.yellow(`Downloading zksolc ${!this._configCompilerPath ? this._version : 'from the remote origin'}`));
            await this._downloadCompiler();
            console.info(chalk_1.default.green(`zksolc ${!this._configCompilerPath ? `version ${this._version}` : 'from the remote origin'} successfully downloaded`));
        }
        catch (e) {
            throw new errors_1.ZkSyncSolcPluginError(e.message.split('\n')[0]);
        }
        await this._postProcessCompilerDownload();
        await this._verifyCompilerAndSetVersionIfNeeded();
    }
    async _downloadCompiler() {
        const downloadPath = this.getCompilerPath();
        const url = this._getCompilerUrl();
        try {
            await this._attemptDownload(url, downloadPath);
        }
        catch (e) {
            if (!this._isCompilerPathURL) {
                await this._attemptDownload(url, downloadPath);
            }
        }
        return downloadPath;
    }
    _getCompilerUrl() {
        if (this._isCompilerPathURL) {
            return this._configCompilerPath;
        }
        return (0, utils_1.getZksolcUrl)(constants_1.ZKSOLC_BIN_REPOSITORY, this._version);
    }
    async _attemptDownload(url, downloadPath) {
        return (0, utils_1.download)(url, downloadPath, constants_1.USER_AGENT, constants_1.DEFAULT_TIMEOUT_MILISECONDS);
    }
    async _postProcessCompilerDownload() {
        const compilerPath = this.getCompilerPath();
        fs_extra_1.default.chmodSync(compilerPath, 0o755);
    }
    async _verifyCompilerAndSetVersionIfNeeded() {
        const compilerPath = this.getCompilerPath();
        const versionOutput = (0, child_process_1.spawnSync)(compilerPath, ['--version']);
        const version = versionOutput.stdout
            ?.toString()
            .match(/\d+\.\d+\.\d+/)
            ?.toString();
        if (versionOutput.status !== 0 || version === null) {
            throw new errors_1.ZkSyncSolcPluginError((0, constants_1.COMPILER_BINARY_CORRUPTION_ERROR)(compilerPath));
        }
        if (this._configCompilerPath) {
            this._version = version;
        }
    }
}
exports.ZksolcCompilerDownloader = ZksolcCompilerDownloader;
ZksolcCompilerDownloader.compilerVersionInfoCachePeriodMs = constants_1.DEFAULT_COMPILER_VERSION_INFO_CACHE_PERIOD;
//# sourceMappingURL=downloader.js.map