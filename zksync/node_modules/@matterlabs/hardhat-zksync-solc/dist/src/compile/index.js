"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerCompiler = exports.BinaryLinker = exports.BinaryCompiler = exports.link = exports.compile = void 0;
const semver_1 = __importDefault(require("semver"));
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
const docker_1 = require("./docker");
const binary_1 = require("./binary");
async function compile(zksolcConfig, input, solcPath) {
    validateFallbackOZOption(zksolcConfig);
    const compiler = await resolveCompiler(zksolcConfig, solcPath);
    return compiler.compile(input, zksolcConfig);
}
exports.compile = compile;
async function link(zksolcConfig, linkLibraries) {
    if (zksolcConfig.compilerSource !== 'binary') {
        throw new errors_1.ZkSyncSolcPluginError('Linking is only supported with binary compiler');
    }
    const linker = new BinaryLinker();
    return linker.link(zksolcConfig, linkLibraries);
}
exports.link = link;
class BinaryCompiler {
    constructor(solcPath) {
        this.solcPath = solcPath;
    }
    async compile(input, config) {
        // Check for missing libraries
        if (semver_1.default.gte(config.version, constants_1.DETECT_MISSING_LIBRARY_MODE_COMPILER_VERSION) &&
            semver_1.default.lt(config.version, constants_1.ZKSOLC_COMPILER_VERSION_WITH_LIBRARY_LINKING)) {
            const zkSolcOutput = await (0, binary_1.compileWithBinary)(input, config, this.solcPath, true);
            const missingLibraries = (0, utils_1.findMissingLibraries)(zkSolcOutput);
            if (missingLibraries.size > 0) {
                if (!config.settings.missingLibrariesPath) {
                    throw new errors_1.ZkSyncSolcPluginError('Missing libraries path is not specified');
                }
                const missingLibraryDependencies = (0, utils_1.mapMissingLibraryDependencies)(zkSolcOutput, missingLibraries);
                // Write missing libraries to file
                const missingLibrariesPath = config.settings.missingLibrariesPath;
                await (0, utils_1.writeLibrariesToFile)(missingLibrariesPath, missingLibraryDependencies);
                config.settings.areLibrariesMissing = true;
                return zkSolcOutput;
            }
        }
        config.settings.areLibrariesMissing = false;
        return await (0, binary_1.compileWithBinary)(input, config, this.solcPath);
    }
}
exports.BinaryCompiler = BinaryCompiler;
/**
 * Dedicated linker for binary builds.
 * Linking does not require the local `solc` binary, only the `zksolc` executable
 * referenced by `config.settings.compilerPath`, therefore no constructor arguments.
 */
class BinaryLinker {
    async link(config, linkLibraries) {
        return await (0, binary_1.linkWithBinary)(config, linkLibraries);
    }
}
exports.BinaryLinker = BinaryLinker;
class DockerCompiler {
    constructor(dockerCompilerImage, docker) {
        this.dockerCompilerImage = dockerCompilerImage;
        this.docker = docker;
    }
    static async initialize(config) {
        await (0, docker_1.validateDockerIsInstalled)();
        const image = (0, docker_1.dockerImage)(config.settings.experimental?.dockerImage, config.settings.experimental?.tag);
        const docker = await (0, docker_1.createDocker)();
        await (0, docker_1.pullImageIfNecessary)(docker, image);
        return new DockerCompiler(image, docker);
    }
    async compile(input, config) {
        // We don't check here for missing libraries because docker is using older versions of zksolc and it's deprecated
        return await (0, docker_1.compileWithDocker)(input, this.docker, this.dockerCompilerImage, config);
    }
    async solcVersion() {
        const versionOutput = await (0, docker_1.getSolcVersion)(this.docker, this.dockerCompilerImage);
        const longVersion = versionOutput.match(/^Version: (.*)$/)[1];
        const version = longVersion.split('+')[0];
        return { version, longVersion };
    }
}
exports.DockerCompiler = DockerCompiler;
/**
 * Throws if the `fallback_to_optimizing_for_size` optimizer flag is used with an old compiler.
 */
function validateFallbackOZOption(config) {
    if (config.settings.optimizer?.fallback_to_optimizing_for_size &&
        semver_1.default.lt(config.version, constants_1.ZKSOLC_COMPILER_MIN_VERSION_WITH_FALLBACK_OZ)) {
        throw new errors_1.ZkSyncSolcPluginError(`fallback_to_optimizing_for_size option in optimizer is not supported for zksolc compiler version ${config.version}. ` +
            `Please use version ${constants_1.ZKSOLC_COMPILER_MIN_VERSION_WITH_FALLBACK_OZ} or higher.`);
    }
}
/**
 * Factory that returns the appropriate compiler implementation
 * based on the userâ€‘supplied configuration.
 */
async function resolveCompiler(config, solcPath) {
    switch (config.compilerSource) {
        case 'binary':
            if (!solcPath) {
                throw new errors_1.ZkSyncSolcPluginError('solc executable is not specified');
            }
            return new BinaryCompiler(solcPath);
        case 'docker':
            return DockerCompiler.initialize(config);
        default:
            throw new errors_1.ZkSyncSolcPluginError(`Incorrect compiler source: ${config.compilerSource}`);
    }
}
//# sourceMappingURL=index.js.map